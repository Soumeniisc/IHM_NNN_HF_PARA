//c++ HF_.cpp -std=c++1y
#include<iostream>
//#include <array>
#include <math.h>       /* cos */
#define PI 3.14159265
#include <vector>
#include <cstdlib>     /* abs */
#include<fstream>// header file for input and output
#include <sstream> 

using namespace std;
class HF {
  long double t,t2,delta,A;
  const static int dim = 2,GRID = 300, bin = 500;
  long double cos_[2*GRID] = {};
  long double lambda_upp[2*GRID][2*GRID] = {{}};
  long double lambda_dnp[2*GRID][2*GRID] = {{}};
  long double lambda_upn[2*GRID][2*GRID] = {{}};
  long double lambda_dnn[2*GRID][2*GRID] = {{}};
  long double L_upp[2*GRID][2*GRID] = {{}};
  long double L_dnp[2*GRID][2*GRID] = {{}};
  long double L_upn[2*GRID][2*GRID] = {{}};
  long double L_dnn[2*GRID][2*GRID] = {{}};
  long double CA_upp[2*GRID][2*GRID] = {{}};
  long double CA_dnp[2*GRID][2*GRID] = {{}};
  long double CA_upn[2*GRID][2*GRID] = {{}};
  long double CA_dnn[2*GRID][2*GRID] = {{}};
  long double CB_upp[2*GRID][2*GRID] = {{}};
  long double CB_dnp[2*GRID][2*GRID] = {{}};
  long double CB_upn[2*GRID][2*GRID] = {{}};
  long double CB_dnn[2*GRID][2*GRID] = {{}};
  long double dos_upp[bin] = {};
  long double dos_upn[bin] = {};
  long double dos_dnp[bin] = {};
  long double dos_dnn[bin] = {};

  public:
  long double nA_upn,nA_dnn,nB_upn,nB_dnn;
  int cnt ;
  HF(long double t_, long double t2_, long double delta_, int dim_){
  	t = t_;
	t2 = t2_;
	delta = delta_;
  
  for(int i = 0; i<2*GRID; i++){
	cos_[i] = cos( (i-GRID)*PI/(GRID));
	}
	} // HF

  long double division(long double a, long double b)
	{
	   if( b == 0 )
	   {
	      throw "Division by zero condition!";
	   }
	   return (a/b);
	}  

  void solve(long double U, long double mu, long double nA_up, long double nA_dn, long double nB_up, long double nB_dn){
  auto nA_up_ =  new (nothrow) long double[2*GRID]();
  auto nB_up_ =  new (nothrow) long double[2*GRID]();
  auto nA_dn_ =  new (nothrow) long double[2*GRID]();
  auto nB_dn_ =  new (nothrow) long double[2*GRID]();
  cnt = 0;
   //cout<<"solver class is created-------------------"<<endl;
   for(int i = 0; i<2*GRID; i++){
	for(int j = 0; j<2*GRID; j++){
		auto energy = 2*t*(cos_[i] + cos_[j]);
		auto energyA = 2*dim*t2*cos_[i]*cos_[j];
		//cout<<energy<<endl;
		auto A_up = delta -mu + U*nA_up - energyA;
		auto A_dn = delta -mu + U*nA_dn - energyA;
		auto B_up = -delta -mu + U*nB_up - energyA;
		auto B_dn = -delta -mu + U*nB_dn - energyA;
		lambda_upp[i][j] = 0.5*( A_dn + B_dn + sqrt( (A_dn - B_dn)*(A_dn - B_dn) + 4*energy*energy) );
		lambda_dnp[i][j] = 0.5*( A_up + B_up + sqrt( (A_up - B_up)*(A_up - B_up) + 4*energy*energy) );
		lambda_upn[i][j] = 0.5*( A_dn + B_dn - sqrt( (A_dn - B_dn)*(A_dn - B_dn) + 4*energy*energy) );
		lambda_dnn[i][j] = 0.5*( A_up + B_up - sqrt( (A_up - B_up)*(A_up - B_up) + 4*energy*energy) );	
		L_upp[i][j] = (A_up - lambda_dnp[i][j]);
                L_dnp[i][j] = (A_dn - lambda_upp[i][j]);
		L_upn[i][j] = (A_up - lambda_dnn[i][j]);
		L_dnn[i][j] = (A_dn - lambda_upn[i][j]);
		if(energy != 0.0 ){
		        try {
	     			CA_upp[i][j] = division(energy*energy,energy*energy + L_upp[i][j]*L_upp[i][j]);
	   		}catch (const char* msg) {
		                 cnt = cnt + 1;
	     			//cout<<"L_upp"<<A_up<< "  "<<B_up<<"  "<<i<<"   "<<j<<":energy:   "<<energy<<"  " <<energyA<<"   "<<(A_up - lambda_dnp[i][j])<<"  "<<cnt<< endl;
	  		}
		try {
	     			CA_upn[i][j] = division(energy*energy,energy*energy + L_upn[i][j]*L_upn[i][j]);
	   		}catch (const char* msg) {
		                 cnt = cnt + 1;
	     		//	cout<<"L_upp"<<A_up<< "  "<<B_up<<"  "<<i<<"   "<<j<<"   "<<energy<<"  " <<energyA<<"   "<<(A_up - lambda_dnp[i][j])<< endl;
			}
		try {
	     			CA_dnp[i][j] = division(energy*energy,energy*energy + L_dnp[i][j]*L_dnp[i][j]);
	   		}catch (const char* msg) {
		                 cnt = cnt + 1;
	     		//	cout<<"L_upp"<<A_up<< "  "<<B_up<<"  "<<i<<"   "<<j<<"   "<<energy<<"  " <<energyA<<"   "<<(A_up - lambda_dnp[i][j])<< endl;
			}
		try {
	     			CA_dnn[i][j] = division(energy*energy,energy*energy + L_dnn[i][j]*L_dnn[i][j]);
	   		}catch (const char* msg) {
		                 cnt = cnt + 1;
	     		//	cout<<"L_upp"<<A_up<< "  "<<B_up<<"  "<<i<<"   "<<j<<"   "<<energy<<"  " <<energyA<<"   "<<(A_up - lambda_dnp[i][j])<< endl;
			}

		// now B sublattice calculation start here.
		 try {
     				CB_upp[i][j] = division(L_upp[i][j]*L_upp[i][j],energy*energy + L_upp[i][j]*L_upp[i][j]);	
   		}catch (const char* msg) {
			cnt = cnt + 1;
			//cout<<"L_dnp"<<A_dn<< "  "<<B_dn<<"  "<<i<<"   "<<j<<"   "<<energy<<"  " <<energyA<<"   "<<(A_dn - lambda_upp[i][j])<< endl;
  		}
                 try {
     				CB_dnp[i][j] = division(L_dnp[i][j]*L_dnp[i][j],energy*energy + L_dnp[i][j]*L_dnp[i][j]);	
   		}catch (const char* msg) {
			cnt = cnt + 1;
			//cout<<"L_dnp"<<A_dn<< "  "<<B_dn<<"  "<<i<<"   "<<j<<"   "<<energy<<"  " <<energyA<<"   "<<(A_dn - lambda_upp[i][j])<< endl;
  		}
                try {
     				CB_upn[i][j] = division(L_upn[i][j]*L_upn[i][j],energy*energy + L_upn[i][j]*L_upn[i][j]);	
   		}catch (const char* msg) {
			cnt = cnt + 1;
			//cout<<"L_dnp"<<A_dn<< "  "<<B_dn<<"  "<<i<<"   "<<j<<"   "<<energy<<"  " <<energyA<<"   "<<(A_dn - lambda_upp[i][j])<< endl;
  		}
                 try {
     				CB_dnn[i][j] = division(L_dnn[i][j]*L_dnn[i][j],energy*energy + L_dnn[i][j]*L_dnn[i][j]);	
   		}catch (const char* msg) {
			cnt = cnt + 1;
			//cout<<"L_dnp"<<A_dn<< "  "<<B_dn<<"  "<<i<<"   "<<j<<"   "<<energy<<"  " <<energyA<<"   "<<(A_dn - lambda_upp[i][j])<< endl;
  		}
		}//end of if(energyA != 0.0)	

		//CA_upp[i][j] = (energy*energy)/(energy*energy + L_upp[i][j]*L_upp[i][j] );
		//CA_dnp[i][j] = (energy*energy)/( energy*energy + L_dnp[i][j]*L_dnp[i][j]);
		//CB_upp[i][j] = (L_upp[i][j]*L_upp[i][j])/( energy*energy + L_upp[i][j]*L_upp[i][j]);
		//CB_dnp[i][j] = (L_dnp[i][j]*L_dnp[i][j])/( energy*energy + L_dnp[i][j]*L_dnp[i][j]);
		//CA_upn[i][j] = (energy*energy)/(energy*energy + L_upn[i][j]*L_upn[i][j] );
		//CA_dnn[i][j] = (energy*energy)/( energy*energy + L_dnn[i][j]*L_dnn[i][j]);
		//CB_upn[i][j] = (L_upn[i][j]*L_upn[i][j])/( energy*energy + L_upn[i][j]*L_upn[i][j]);
		//CB_dnn[i][j] = (L_dnn[i][j]*L_dnn[i][j])/( energy*energy + L_dnn[i][j]*L_dnn[i][j]);
	
	} // for(int i = 0; i<2*GRID; i++)
  } // for(int j = 0; j<2*GRID; j++)

 
  nA_upn = 0.0;
  nA_dnn = 0.0;
  nB_upn = 0.0;
  nB_dnn = 0.0;
  for(int j = 0; j<2*GRID; j++){
	for(int i = 0; i<2*GRID; i++){
		
			if (lambda_upp[i][j]<0.0){
				nA_up_[j] = nA_up_[j] + CA_dnp[i][j]; 
			        nB_up_[j] = nB_up_[j] + CB_dnp[i][j]; 
				}
			if (lambda_dnp[i][j]<0.0){ 
				nA_dn_[j] = nA_dn_[j] + CA_upp[i][j];
				nB_dn_[j] = nB_dn_[j] + CB_upp[i][j];
				}
			if (lambda_upn[i][j]<0.0){ 
				nA_up_[j] = nA_up_[j] + CA_dnn[i][j]; 
				nB_up_[j] = nB_up_[j] + CB_dnn[i][j];
				}
			if (lambda_dnn[i][j]<0.0){
				nA_dn_[j] = nA_dn_[j] + CA_upn[i][j];
				nB_dn_[j] = nB_dn_[j] + CB_upn[i][j];
				}
			
	
	} //for(int i = 0; i<2*GRID; i++)

    
		nA_upn = nA_upn + nA_up_[j];
		nA_dnn = nA_dnn + nA_dn_[j];
		nB_upn = nB_upn + nB_up_[j];
		nB_dnn = nB_dnn + nB_dn_[j];
		
  } //for(int j = 0; j<2*GRID; j++)
 delete[] nA_up_;
 delete[] nB_up_;
 delete[] nA_dn_;
 delete[] nB_dn_;
 nA_upn = nA_upn/(4*GRID*GRID);
 nA_dnn = nA_dnn/(4*GRID*GRID);
 nB_upn = nB_upn/(4*GRID*GRID);
 nB_dnn = nB_dnn/(4*GRID*GRID);
 }	//solve

  long double get_GRID(){ return 2*t; };
  auto get_lambda(){return lambda_upp[0][0];}

  auto energy_(long double U, long double mu, long double nA_up, long double nA_dn, long double nB_up, long double nB_dn){	
	long double free_energy=0.0;	
	for(int j = 0; j<2*GRID; j++){
		for(int i = 0; i<2*GRID; i++){
			auto energy = 2*t*(cos_[i] + cos_[j]);
			auto energyA = 2*dim*t2*cos_[i]*cos_[j];
			auto A_up = delta -mu + U*nA_up - energyA;
			auto A_dn = delta -mu + U*nA_dn - energyA;
			auto B_up = -delta -mu + U*nB_up - energyA;
			auto B_dn = -delta -mu + U*nB_dn - energyA;
			lambda_upp[i][j] = 0.5*( A_dn + B_dn + sqrt( (A_dn - B_dn)*(A_dn - B_dn) + 4*energy*energy) ); 
			lambda_dnp[i][j] = 0.5*( A_up + B_up + sqrt( (A_up - B_up)*(A_up - B_up) + 4*energy*energy) );
			lambda_upn[i][j] = 0.5*( A_dn + B_dn - sqrt( (A_dn - B_dn)*(A_dn - B_dn) + 4*energy*energy) );
			lambda_dnn[i][j] = 0.5*( A_up + B_up - sqrt( (A_up - B_up)*(A_up - B_up) + 4*energy*energy) );	
			if (lambda_upp[i][j]<mu){
				free_energy = free_energy + lambda_upp[i][j] ;
				}
			if (lambda_dnp[i][j]<mu){
				free_energy = free_energy + lambda_dnp[i][j] ;
				}
			if (lambda_upn[i][j]<mu){
				free_energy = free_energy + lambda_upn[i][j] ;
				}
			if (lambda_dnn[i][j]<mu){
				free_energy = free_energy + lambda_dnn[i][j] ;
				}
			}//for i
		}//for j
	 return (free_energy/(4*GRID*GRID))- U*nA_up*nA_dn - U*nB_up*nB_dn;
  }//energy_

};//class

long double abs(long double a){
	if (a>0.0){
		return a;
	}
	else{
		return -1.0*a;
	}
	}

int main(){
  double m,t,t2,delta,U,mu,ms,dn;
  double long free_energy_;
  int dim,GRID,n;
  VecDoub_IO  x(2);
  t = 0.5;
  t2 = 0.0;
  delta = 0.0;
  dim = 2;
  GRID = 200;
  U = 0.0;
  mu = 0.0;

  HF hf(t,t2,delta,dim);


  stringstream energy_file;
  energy_file<<"delta0.0_t20.0_broyden_para_energy.dat";
  ofstream soumen(energy_file.str());
  soumen <<"# U, free_energy"<<endl;

  stringstream data_file;
  data_file<<"delta0.0_t20.0_broyden_para.dat";
  //std::cout<<"out put file:"<<data_file<<std::endl;
  ifstream infile; 
  infile.open(data_file.str());  
  if(infile.is_open()){std::cout<<"file"<<data_file.str()<<" is open"<<endl;}
  else{std::cout<<"no file:"<<data_file.str()<<" in working directroy"<<std::endl;}
   std::string line;
   while (std::getline(infile, line)) {
	//std::cout<<line<<endl;
	if(line[0] != '#'){
		//std::cout<<line<<endl;
   		std::istringstream ss(line);
		ss >> U >> mu >> m >> dn >> m >> ms; 
		std::cout<<U <<"  mu:"<<mu << m << dn << m <<"ms:"<< ms<<endl;
                auto nA_up =  0.5*(1.0-dn+ms);
  		auto nB_up =  0.5*(1.0+dn-ms);
  		auto nA_dn =  0.5*(1.0-dn-ms);
  		auto nB_dn =  0.5*(1.0+dn+ms);
		//dos_(double U, double mu, double nA_up, double nA_dn, double nB_up, double nB_dn, double min_energy, double max_energy)
	        free_energy_ = hf.energy_(U, mu, nA_up, nA_dn, nB_up,nB_dn);
		soumen << U<<"  "<<free_energy_<<std::endl;
		std::cout<<"free_energy_:"<<free_energy_<<std::endl;
	}//if
    
   }//while
  
  return 0;

} //main
